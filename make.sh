#!/usr/bin/env sh

NAME="$( basename "${0}"; printf a )"; NAME="${NAME%?a}"

show_help() {
  <<EOF cat - >&2
SYNOPSIS
  ${NAME} <SUBCOMMAND> [--force]

DESCRIPTION
  One of the two UIs for building the blog. Similar to makefile, you can
  specify several SUBCOMMANDs together

  e.g. \`${NAME} clean build-host\`

  'Building' means do compile step and link step

SUBCOMMAND
  clean                 Deletes the cache and public directories
  build                 Builds both the website and the blog posts
  build-rust            Compiles rust to release (use --debug-profile)

  relink                Run linker step with --force (skip slow compile step)
  server                Does 'relink-host' and then starts the server
  start-server-only     Start server for previewing public (NOT for production)
  delete-generated <1>  Deletes files and cache lines generated into cache and
                        public directories made from <1> (i.e. same file stem)


  clean-all             Deletes the cache, public, and target directories
  clean-public          Deletes the \${PUBLIC} directory
  clean-cache           Deletes the \${CACHE} directory
  build-all             Runs build-blog, build-rust, build-website
  build-blog            Builds all the blog posts
  build-website         Builds the website (compile/link/copy source -> public)
  build-local           'build' designed for opening via 'file://' in browser
  build-host            'build' (default) for 'http://localhost:${PORT}/'
  relink-local          'relink' designed for opening via 'file://' in browser
  relink-host           'relink' (default) for 'http://localhost:${PORT}/'

OPTIONS
  --help (alias: -h)
    Display this help message

  --debug-profile (alias: -d)
    Run with 'cargo run'

  --explicit (alias: -e)
    Even more information

  --force (alias: -f)
    Forces recompiling

  --verbose (alias: -v)
    Details every options more explicitly
EOF
}

NL='
'

# TODO: https://stackoverflow.com/questions/4823468/comments-in-markdown

# NOTE: Make sure to not set ${b_args} here (used in blog.sh)
main() {
  wd="$( dirname "${0}"; printf a )"; wd="${wd%${NL}a}"
  cd "${wd}" || exit "$?"
  PROJECT_HOME="$( pwd -P; printf a )"; PROJECT_HOME="${PROJECT_HOME%${NL}a}"

  ##############################################################################
  # Customize these
  ###
  # Paths relative to ${PWD} (this is where this script is located)
  export        CONFIG="config"  #
  export BLOG_RELATIVE="blog"    # Stores posts and custom pages for blog
                SOURCE="source"  # Your website's HTML, CSS, etc. files
                PUBLIC="public"  # Where the web server should point to
                 CACHE=".cache"  # For the temporary files generated by ${BLOG_API}

  # Sub-paths of the above
  export   FILE_EXT_API="${CONFIG}/api"                # Handles post file types
  export         DRAFTS="${CONFIG}/drafts"             # Post drafts
  export      PUBLISHED="${CONFIG}/published"          # Where drafts are moved
  export POST_TEMPLATES="${CONFIG}/post-templates"     #
  export SITE_TEMPLATES="${CONFIG}/website-templates"  #

  # For customising the content of your posts
  export AUTHOR=""                           # Your name

  # This is for links to have the proper value if you view them locally
  # TODO: add local web hosting to ${BLOG_API}
  #DOMAIN="${PROJECT_HOME}/${PUBLIC}"  # If local  (file:///...)
  DOMAIN=""                           # If server (http://...)
  FILES_TO_PROCESS_LIMIT=10000
  POST_OUTPUT="${BLOG_RELATIVE}/{lang}/{year}-{month}-{day}-{file_stem}.html"
  ##############################################################################

                PORT="8080" # for the dev server
          TAGS_CACHE="${CACHE}/tags.csv"
          LINK_CACHE="${CACHE}/link.csv"
  export BLOG_OUTPUT="${PUBLIC}/${BLOG_RELATIVE}"
  export BLOG_API="./$(
    sed -n '1,/\[\[bin\]\]/d;s/"$//;s/^name = "//p' "Cargo.toml"
  )"

  # Flags
  FORCE='false'
  DEBUG='false'
  EXPLICIT=''
  VERBOSE=''

  # Options processing
  args=''
  for a in "$@"; do case "${a}"
    in -h|--help)  show_help; exit 0
    ;; -d|--debug-build)  DEBUG='true'
    ;; -e|--explicity)    EXPLICIT='--explicit'
    ;; -f|--force)        FORCE='true'
    ;; -v|--verbose)      VERBOSE='--verbose'

    ;; -*) die FATAL 1 "Invalid option '${a}'. See \`${NAME} -h\` for help"
    ;; *)  args="${args} ${a}"
  esac; done

  # By this point, we should export the variables on no ${subcommand} given
  # because while `. make.sh` can have arguments, it should not
  [ -z "${args}" ] && { show_help; return 1; }

  do_commands ${args}
}

check_if_api_exists() {
  [ ! -x "${BLOG_API}" ] && die FATAL 1 \
    "'${BLOG_API}' was not found (blog api)." \
    "Run \`${NAME} build-rust\` (though one should be provided)"
}

do_commands() {
  # Then check if it exists

  while [ "$#" -gt 0 ]; do
    case "${1}"
      in clean-cache)
        errln "Removing contents of '${CACHE}/'..."
        rm -rf "${CACHE}"

      ;; clean-public)
        errln "Removing contents of '${PUBLIC}/'..."
        rm -rf "${PUBLIC}"

      ;; clean)
        errln "Removing contents of '${CACHE}' and '${PUBLIC}/'..."
        rm -rf "${CACHE}" "${PUBLIC}"

      ;; clean-all)
        errln "Removing contents of '${CACHE}/', '${PUBLIC}/', 'target/' ..."
        require 'cargo'
        rm -rf "${CACHE}"
        rm -rf "${PUBLIC}"
        cargo clean
        rm "${BLOG_API}"



      ;; build-rust)
        errln "Compiling rust..." "======="
        build_rust

      ;; build-blog)
        check_if_api_exists
        if rust_api 'compile' "${PUBLISHED}"; then
          build_blog_indices
        fi

      ;; build-website)
        check_if_api_exists
        errln "Building the website..." "======="
        build_website

      ;; build-all)          do_commands 'build-rust' 'build'



      ;; build-local)
        errln "Using DOMAIN='${PROJECT_HOME}/${PUBLIC}' for build"
        DOMAIN="${PROJECT_HOME}/${PUBLIC}" do_commands 'build'

      ;; build-host)    DOMAIN='' do_commands 'build'
        errln "Using DOMAIN='' for build"
        DOMAIN="" do_commands 'build'

      ;; build)              do_commands 'build-blog' 'build-website'



      ;; relink-local)
        errln "Using DOMAIN='${PROJECT_HOME}/${PUBLIC}' for relink"
        DOMAIN="${PROJECT_HOME}/${PUBLIC}" do_commands 'relink'
      ;; relink-host)
        errln "Using DOMAIN='' for relink"
        DOMAIN="" do_commands 'relink'
      ;; relink)
        check_if_api_exists
        if rust_api 'relink' "${PUBLISHED}"; then
          build_blog_indices
          errln
          do_commands 'build-website'
        fi



      # BUG: `./make.sh delete-generated build-rust` is technically invalid if
      #      build-rust is a file (but posts probably always have an extension)
      ;; delete-generated)
        [ -n "${2}" ] || die FATAL 1 "\`${NAME} ${1}\` needs a second argument"
        [ -f "${2}" ] || die FATAL 1 "File '${2}' does not exist"
        rust_api 'delete-generated' "${2}"; shift 1

      ;; start-server-only)  rust_api 'start-server' "${PORT}"

      ;; server)
        DOMAIN='' do_commands 'relink' 'start-server'
      #;; test)

      ;; *) die FATAL 1 "\`${NAME} '${1}'\` is an invalid subcommand."
    esac
    shift 1
    [ "$#" -gt 0 ] && errln
  done
}


#run: DOMAIN='' ./make.sh build-local

#blah() {
#  <<EOF cat - >"${TAGS_CACHE}"
#Junk,2019-11-01,stuff,en,The Quick, brown fox jumped over the lazy doggo
#Junk,2019-11-01,stuff,jp,これはこれはどういう意味なんだろう
#Linguistics,2019-11-01,stuff,en,The Quick, brown fox jumped over the lazy doggo
#Linguistics,yo,happy-times,zh,辣妹
#EOF
#}

build_rust() {
  # must not use FORCE, or we have to redo main
  require 'cargo' || die FATAL 1 "Could not find the executable '${BLOG_API}'" \
    "And without cargo/rust installed, you cannot compile."
  cargo build --release
  ! cmp -s "target/release/${BLOG_API}" "${BLOG_API}" \
    && cp "target/release/${BLOG_API}" ./
}

build_website() {
    mkdir -p "${PUBLIC}"
    do_for_each_file_in "${SOURCE}" "${SOURCE}/" compile
}

build_blog_indices() {
  mkdir -p "${CACHE}" "${BLOG_OUTPUT}"
  export LANG_LIST="$( <"${TAGS_CACHE}" cut -d ',' -f 4 | sort | uniq )"

  index_output="${BLOG_OUTPUT}/index.html"
  errln "Creating blog landing page '${index_output}'"
  "${SITE_TEMPLATES}/blog-index.sh" "${TAGS_CACHE}" "${LINK_CACHE}" \
    | "${CONFIG}/combine.sh" \
      "navbar=v:$( "${SITE_TEMPLATES}/navbar.sh" \
        "${DOMAIN}" "${index_output#"${PUBLIC}/"}" "" )" \
    >"${index_output}" || exit "$?"

  for lang in ${LANG_LIST}; do
    tags_output="${BLOG_OUTPUT}/tags-${lang}.html"
    errln "Making tags index page '${tags_output}'"
    "${SITE_TEMPLATES}/tags.sh" "${TAGS_CACHE}" "${LINK_CACHE}" "${lang}" \
      | "${CONFIG}/combine.sh" \
        "navbar=v:$( "${SITE_TEMPLATES}/navbar.sh" \
          "${DOMAIN}" "${tags_output#"${PUBLIC}/"}" "" )" \
      >"${tags_output}" || exit "$?"
  done
}

rust_api() {
  if "${DEBUG}"
    then _api='cargo';       _args='run --'
    else _api="${BLOG_API}"; _args=''
  fi
  if "${FORCE}"
    then _force='--force'
    else _force=''
  fi
  #"${BLOG_API}" ${_args} "$@" \
  "${_api}" ${_args} "$@" \
    --api-dir "${FILE_EXT_API}" \
    --blog-relative "${BLOG_RELATIVE}" \
    --cache-dir "${CACHE}" \
    --domain "${DOMAIN}" \
    --linker "${SITE_TEMPLATES}/post.sh" \
    --output-format "${POST_OUTPUT}" \
    --public-dir "${PUBLIC}" \
    --templates-dir "${SITE_TEMPLATES}" \
    ${EXPLICIT} \
    ${_force} \
    ${VERBOSE} \
  # end
}

update() {
  filename="${1##*/}"
  parent="${1%"${filename}"}"  # has trailing '/' if not root
  filename="${filename%."${2}"}"

  from_rel="${1}"
  from="${SOURCE}/${from_rel}"
  into_rel="${parent}${filename}.${3}"
  into="${PUBLIC}/${into_rel}"
  mkdir -p "${PUBLIC}/${parent}"

  shift 3 || exit "$?"
  if "${FORCE}" || rust_api 'is-first-newer-than' "${from}" "${into}"; then
    "$@" "${from}" "${into}" || exit "$?"
    rust_api 'sync-last-updated-of-first-to' "${from}" "${into}"
    errln "Processed '\${SOURCE}/${from_rel}' -> '\${PUBLIC}/${into_rel}'"
  else
    errln "Not updated '\${SOURCE}/${from_rel}' <> '\${PUBLIC}/${into_rel}'"
  fi
}

compile_html() {
  <"${1}" "${CONFIG}/combine.sh" \
    "prefix=v:${DOMAIN}" \
    "navbar=v:$(
      "${SITE_TEMPLATES}/navbar.sh" "${DOMAIN}" "${2#"${PUBLIC}/"}" ""
    )" \
  >"${2}" || exit "$?"
}

compile_sh() {
  sh "${1}" | "${CONFIG}/combine.sh" \
    "prefix=v:${DOMAIN}" \
    "navbar=v:$(
      "${SITE_TEMPLATES}/navbar.sh" "${DOMAIN}" "${2#"${PUBLIC}/"}" ""
    )" \
  #>"${2}" || exit "$?"
}

compile() {
  # $1: relative path to file to compile (so without ${PUBLIC})
  if [ -h "${SOURCE}/${1}" ]; then
    if "${FORCE}" || [ ! -e "${PUBLIC}/${1}" ]; then
      errln "Relinking '\${SOURCE}/${1}' -> '\${PUBLIC}/${1}'"
      cp -P "${SOURCE}/${1}" "${PUBLIC}/${1}"
    else
      errln "Not updated '\${SOURCE}/${1}' <> '\${PUBLIC}/${1}'"
    fi

  elif [ ! -f "${SOURCE}/${1}" ]; then
    die FATAL 1 "Can only compile files, '${SOURCE}/${1}' is not a file"

  else
    extension="${1##*/}"
    extension="${extension##*.}"

    case "${extension}"
      in html)      update "${1}" "${extension}" html compile_html
      ;; css|js)    update "${1}" "${extension}" html cp
      ;; sass|scss) update "${1}" "${extension}" css  sassc
      ;; sh)        update "${1}" "${extension}" html compile_sh

      ;; "${1}") die FATAL 1 "'${1}' has no file extension"
      ;; *)      die FATAL 1 \
        "The extension '${ext}' for '${1}' is unsupported. Add it?"
    esac
  fi
}

# Follows symlinks
do_for_each_file_in() {
  # $1: directory to recurse through
  # $2: prefix to remove from pathnames (typically "${1}/")
  # $3...: command to run, will add argument for file

  #[ "${1}" != "${1#/}" ] || die DEV 1 "'${1}' must be an absolute path"
  [ "${1}" != "${1#././}" ] && die DEV 1 "'${1}' must be in canonical form"
  [ -d "${1}" ] || die FATAL 1 "'${1}' is not a directory"

  # 'fe' for 'for each'
  fe_to_process="././${1}"
  fe_prefix_to_remove="${2}"
  shift 2
  fe_count=0
  while [ -n "${fe_to_process}" ]; do
    fe_dir="${fe_to_process%%././*}"
    fe_to_process="${fe_to_process#"${fe_dir}"}"
    fe_to_process="${fe_to_process#././}"
    fe_dir="${fe_dir#././}"

    if [ -n "${fe_dir}" ]; then
      for fe_node in "${fe_dir}"/* "${fe_dir}"/.[!.]* "${fe_dir}"..?*; do
        [ ! -e "${fe_node}" ] && continue
        fe_count="$(( fe_count + 1 ))"
        [ "${fe_count}" -gt "${FILES_TO_PROCESS_LIMIT}" ] && die FATAL 1 \
          "Files processed in '${1}' > '${FILES_TO_PROCESS_LIMIT}'" \
          "Increase \${FILES_TO_PROCESS_LIMIT} inside of '${NAME}'"

        if [ ! -h "${fe_node}" ] && [ -d "${fe_node}" ]; then
          fe_to_process="${fe_to_process}././${fe_node}"
          continue
        fi
        "$@" "${fe_node#"${fe_prefix_to_remove}"}"
      done
    fi
  done
}

outln() { printf %s\\n "$@"; }
errln() { printf %s\\n "$@" >&2; }
die() { printf %s "${1}: " >&2; shift 1; printf %s\\n "$@" >&2; exit "${1}"; }
require() {
  for dir in $( printf %s "${PATH}" | tr ':' '\n' ); do
    [ -f "${dir}/${1}" ] && [ -x "${dir}/${1}" ] && return 0
  done
  return 1
}

main "$@"
