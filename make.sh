#!/usr/bin/env sh

NAME="$( basename "${0}"; printf a )"; NAME="${NAME%?a}"

show_help() {
  <<EOF cat - >&2
SYNOPSIS
  ${NAME} <SUBCOMMAND> [--force]

DESCRIPTION
  One of the two UIs for building the blog. Similar to makefile, you can
  specify several SUBCOMMANDs

SUBCOMMAND
 clean-public
 clean-cache
 clean-all
 compile-blog
 compile-website
 build-rust
 build             Builds both the website and the 

OPTIONS
  --help (alias: -h)
    Display this help message

  --force (alias: -f)
    Forces recompiling

EOF
}

NL='
'

# TODO: https://stackoverflow.com/questions/4823468/comments-in-markdown

# NOTE: Make sure to not set ${b_args} here (used in blog.sh)
main() {
  wd="$( dirname "${0}"; printf a )"; wd="${wd%${NL}a}"
  cd "${wd}" || exit "$?"
  PROJECT_HOME="$( pwd -P; printf a )"; PROJECT_HOME="${PROJECT_HOME%${NL}a}"

  ##############################################################################
  # Customize these
  ###
  # Paths relative to ${PWD} (this is where this script is located)
  export CONFIG="config"  #
         SOURCE="source"  # Your website's HTML, CSS, etc. files
         PUBLIC="public"  # Where the web server should point to
          CACHE=".cache"  # For the temporary files generated by ${BLOG_API}

  # Sub-paths of the above
  export   FILE_EXT_API="${CONFIG}/api"                # Handles post file types
            BLOG_OUTPUT="${PUBLIC}/blog"               # Stores posts output
  export         DRAFTS="${CONFIG}/drafts"             # Post drafts
  export      PUBLISHED="${CONFIG}/published"          # Where drafts are moved
  export POST_TEMPLATES="${CONFIG}/post-templates"     #
  export SITE_TEMPLATES="${CONFIG}/website-templates"  #

  # For customising the content of your posts
  export AUTHOR=""                           # Your name

  # This is for links to have the proper value if you view them locally
  # TODO: add local web hosting to ${BLOG_API}
  #DOMAIN="${PROJECT_HOME}/${PUBLIC}"  # If local  (file:///...)
  #DOMAIN=""                           # If server (http://...)
  FILES_TO_PROCESS_LIMIT=10000
  POST_OUTPUT="blog/{lang}/{year}-{month}-{day}-{file_stem}.html"
  ##############################################################################

         TAGS_CACHE="${CACHE}/tags.csv"
         LINK_CACHE="${CACHE}/link.csv"
  export BLOG_API="./$(
    sed -n '1,/\[\[bin\]\]/d;s/"$//;s/^name = "//p' "Cargo.toml"
  )"

  # Flags
  FORCE='false'

  # Options processing
  args=''
  for a in "$@"; do case "${a}"
    in -h|--help)  show_help; exit 0
    ;; -f|--force) FORCE='true'

    ;; -*) die FATAL 1 "Invalid option '${a}'. See \`${NAME} -h\` for help"
    ;; *)  args="${args} ${a}"
  esac; done

  # By this point, we should export the variables on no ${subcommand} given
  # because while `. make.sh` can have arguments, it should not
  [ -z "${args}" ] && { show_help; return 1; }

  eval "set -- ${args}"

  # Run this first
  for subcommand in "$@"; do case "${subcommand}"
    in build-rust)    build_rust
  esac; done

  # Then check if it exists
  [ ! -x "${BLOG_API}" ] && die FATAL 1 \
    "'${BLOG_API}' was not found (blog api)." \
    "Run \`${NAME} build-rust\` (though one should be provided)"

  for subcommand in "$@"; do case "${subcommand}"
    in clean-cache)
      outln "Removing contents of '${CACHE}/'..."
      rm -rf "${CACHE}"
    ;; clean-public)
      outln "Removing contents of '${PUBLIC}/'..."
      rm -rf "${PUBLIC}"
    ;; clean-all)
      outln "Removing contents of '${CACHE}/', '${PUBLIC}/', 'target/' ..."
      require 'cargo'
      rm -rf "${CACHE}"
      rm -rf "${PUBLIC}"
      cargo clean
      rm "${BLOG_API}"

    ;; compile-blog)  compile_blog
    ;; compile-website)
      errln "Building just the website (without the blog)..."
      mkdir -p "${PUBLIC}"
      do_for_each_file_in "${SOURCE}" "${SOURCE}/" compile

    ;; build-rust)     # already handled
    ;; build)
      errln "Building the website and the blog"
      mkdir -p "${PUBLIC}"
      do_for_each_file_in "${SOURCE}" "${SOURCE}/" compile
      compile_blog

    ;; test)
      #errln "for testing"
      #build_rust
      #compile_post "${PUBLISHED}/blue.adoc"
      #<"${TAGS_CACHE}" sieve_out_name "chinese_tones"
      compile_blog

    ;; *) die FATAL 1 "\`${NAME} '${1}'\` is an invalid subcommand."
  esac; done
}
blah() {
  <<EOF cat - >"${TAGS_CACHE}"
Junk,2019-11-01,stuff,en,The Quick, brown fox jumped over the lazy doggo
Junk,2019-11-01,stuff,jp,これはこれはどういう意味なんだろう
Linguistics,2019-11-01,stuff,en,The Quick, brown fox jumped over the lazy doggo
Linguistics,yo,happy-times,zh,辣妹
EOF
}

#sieve_out_name() {
#  # $1: the filename to remove (no extension)
#  while IFS=',' read -r _tag _time _name _lang _title; do
#    if [ -n "${_tag}" ] && [ "${_name}" != "${1}" ]; then
#      outln "${_tag},${_time},${_name},${_lang},${_title}"
#    fi
#  done
#  if  [ -n "${_tag}" ] && [ "${_name}" != "${1}" ]; then
#    outln "${_tag},${_time},${_name},${_lang},${_title}"
#  fi
#}

build_rust() {
  # must not use FORCE, or we have to redo main
  require 'cargo' || die FATAL 1 "Could not find the executable '${BLOG_API}'" \
    "And without cargo/rust installed, you cannot compile."
  cargo build --release
  ! cmp -s "target/release/${BLOG_API}" "${BLOG_API}" \
    && cp "target/release/${BLOG_API}" ./
}

compile_blog() {
  if "${FORCE}" || [ ! -e "${BLOG_OUTPUT}" ]
    then full_rebulid='true'
    else full_rebuild='false'
  fi
  mkdir -p "${CACHE}" "${BLOG_OUTPUT}"

  tags_cache=''
  link_cache=''
  compile_error='0'
  for file in "${PUBLISHED}"/*; do
    name="${file##*/}"
    extn="${name##*.}"
    name="${file%."${extn}"}"

    output="$( compile_post "${file}" )" || { compile_error="$?"; break; }
    # The format is
    # - number link-cache lines (this is the number of following entries)
    # - link-cache line
    # - second tag-cache line (if more than one lang)
    if [ "${compile_error}" = 0 ]; then
      num="${output%%${NL}*}"
      output="${output#"${num}${NL}"}"
      
      # Separate the link-cache lines from the tag-cache lines
      while [ "${num}" -gt 0 ]; do
        line="${output%%${NL}*}"
        output="${output#*${NL}}"
        link_cache="${link_cache}${line}${NL}"
        num="$(( num - 1 ))"
      done
      tags_cache="${tags_cache}${output}${NL}"
    fi
  done

  if [ "${compile_error}" = 0 ]; then
    errln "Updating link cache '${LINK_CACHE}'"
    outln "${link_cache}" | sort | sed '/^$/d' >"${LINK_CACHE}"
    errln "Updating tags cache '${TAGS_CACHE}'"
    outln "${tags_cache}" | sort | sed '/^$/d' >"${TAGS_CACHE}"

    errln "Creating blog landing page '${BLOG_OUTPUT}/index.html'"
    index_output="${BLOG_OUTPUT}/index.html"
    "${SITE_TEMPLATES}/blog-index.sh" "${TAGS_CACHE}" "${LINK_CACHE}" \
      | "${CONFIG}/combine.sh" \
        "domain=v:${DOMAIN}" \
        "navbar=v:$( "${SITE_TEMPLATES}/navbar.sh" \
          "${DOMAIN}" "${index_output#"${PUBLIC}/"}" )" \
      >"${index_output}" || exit "$?"

    errln "Making tags index page '${tags_output}'"
    tags_output="${BLOG_OUTPUT}/tags.html"
    "${SITE_TEMPLATES}/tags.sh" "${TAGS_CACHE}" "${LINK_CACHE}" \
      | "${CONFIG}/combine.sh" \
        "domain=v:${DOMAIN}" \
        "navbar=v:$( "${SITE_TEMPLATES}/navbar.sh" \
          "${DOMAIN}" "${tags_output#"${PUBLIC}/"}" )" \
      >"${tags_output}"
  else
    exit "${compile_error}"
  fi

}

#backup_tags() {
#  if [ -f "${TAGS_CACHE}" ]; then
#    mv TAGS_BACKUP
#  sed
#}

compile_post() {
  # $1: path to the post to compile
  #cargo run compile-markup "${1}" "${SITE_TEMPLATES}/post.sh" \
  if "${FORCE}"
    then _force_option="--force"
    else _force_option=""
  fi
  "${BLOG_API}" compile-markup "${1}" "${SITE_TEMPLATES}/post.sh" \
    "${POST_OUTPUT}" \
    --api-dir "${FILE_EXT_API}" \
    --cache-dir "${CACHE}" \
    --domain "${DOMAIN}" \
    --public-dir "${PUBLIC}" \
    --templates-dir "${SITE_TEMPLATES}" \
    ${_force_option} \
  # end

}



#run: sh % test
update() {
  filename="${1##*/}"
  parent="${1%"${filename}"}"  # has trailing '/' if not root
  filename="${filename%."${2}"}"

  from_rel="${1}"
  from="${SOURCE}/${from_rel}"
  into_rel="${parent}${filename}.${3}"
  into="${PUBLIC}/${into_rel}"
  mkdir -p "${PUBLIC}/${parent}"

  shift 3 || exit "$?"
  if "${FORCE}" || "${BLOG_API}" is-first-newer-than "${from}" "${into}"; then
    "$@" "${from}" "${into}" || exit "$?"
    "${BLOG_API}" sync-last-updated-of-first-to "${from}" "${into}"
    errln "Processed '\${SOURCE}/${from_rel}' -> '\${PUBLIC}/${into_rel}'"
  else
    errln "Not updated '\${SOURCE}/${from_rel}' <> '\${PUBLIC}/${into_rel}'"
  fi
}

compile_html() {
  <"${1}" "${CONFIG}/combine.sh" \
    "prefix=v:${DOMAIN}" \
    "navbar=v:$(
      "${SITE_TEMPLATES}/navbar.sh" "${DOMAIN}" "${2#"${PUBLIC}/"}"
    )" \
  >"${2}" || exit "$?"
}

compile_sh() {
  sh "${1}" | "${CONFIG}/combine.sh" \
    "prefix=v:${DOMAIN}" \
    "navbar=v:$(
      "${SITE_TEMPLATES}/navbar.sh" "${DOMAIN}" "${2#"${PUBLIC}/"}"
    )" \
  #>"${2}" || exit "$?"
}

compile() {
  # $1: relative path to file to compile (so without ${PUBLIC})
  if [ -h "${SOURCE}/${1}" ]; then
    if "${FORCE}" || [ ! -e "${PUBLIC}/${1}" ]; then
      errln "Relinking '\${SOURCE}/${1}' -> '\${PUBLIC}/${1}'"
      cp -P "${SOURCE}/${1}" "${PUBLIC}/${1}"
    else
      errln "Not updated '\${SOURCE}/${1}' <> '\${PUBLIC}/${1}'"
    fi

  elif [ ! -f "${SOURCE}/${1}" ]; then
    die FATAL 1 "Can only compile files, '${SOURCE}/${1}' is not a file"

  else
    extension="${1##*/}"
    extension="${extension##*.}"

    case "${extension}"
      in html)      update "${1}" "${extension}" html compile_html
      ;; css|js)    update "${1}" "${extension}" html cp
      ;; sass|scss) update "${1}" "${extension}" css  sassc
      ;; sh)        update "${1}" "${extension}" html compile_sh

      ;; "${1}") die FATAL 1 "'${1}' has no file extension"
      ;; *)      die FATAL 1 \
        "The extension '${ext}' for '${1}' is unsupported. Add it?"
    esac
  fi
}

# Follows symlinks
do_for_each_file_in() {
  # $1: directory to recurse through
  # $2: prefix to remove from pathnames (typically "${1}/")
  # $3...: command to run, will add argument for file

  #[ "${1}" != "${1#/}" ] || die DEV 1 "'${1}' must be an absolute path"
  [ "${1}" != "${1#././}" ] && die DEV 1 "'${1}' must be in canonical form"
  [ -d "${1}" ] || die FATAL 1 "'${1}' is not a directory"

  # 'fe' for 'for each'
  fe_to_process="././${1}"
  fe_prefix_to_remove="${2}"
  shift 2
  fe_count=0
  while [ -n "${fe_to_process}" ]; do
    fe_dir="${fe_to_process%%././*}"
    fe_to_process="${fe_to_process#"${fe_dir}"}"
    fe_to_process="${fe_to_process#././}"
    fe_dir="${fe_dir#././}"

    if [ -n "${fe_dir}" ]; then
      for fe_node in "${fe_dir}"/* "${fe_dir}"/.[!.]* "${fe_dir}"..?*; do
        [ ! -e "${fe_node}" ] && continue
        fe_count="$(( fe_count + 1 ))"
        [ "${fe_count}" -gt "${FILES_TO_PROCESS_LIMIT}" ] && die FATAL 1 \
          "Files processed in '${1}' > '${FILES_TO_PROCESS_LIMIT}'" \
          "Increase \${FILES_TO_PROCESS_LIMIT} inside of '${NAME}'"

        if [ ! -h "${fe_node}" ] && [ -d "${fe_node}" ]; then
          fe_to_process="${fe_to_process}././${fe_node}"
          continue
        fi
        "$@" "${fe_node#"${fe_prefix_to_remove}"}"
      done
    fi
  done
}

outln() { printf %s\\n "$@"; }
errln() { printf %s\\n "$@" >&2; }
die() { printf %s "${1}: " >&2; shift 1; printf %s\\n "$@" >&2; exit "${1}"; }
require() {
  for dir in $( printf %s "${PATH}" | tr ':' '\n' ); do
    [ -f "${dir}/${1}" ] && [ -x "${dir}/${1}" ] && return 0
  done
  return 1
}

main "$@"
